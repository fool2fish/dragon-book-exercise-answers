# Exercises for Section 8.2

### 8.2.1

Generate code for the following three-address statements assuming all variables are stored in memory locations.

1. x = 1
2. x = a
3. x = a + 1
4. x = a + b
5. The two statements
    - x = b * c
    - y = a + x

#### answer

    1.  LD R1, #1
        ST x, R1

    2.  LD R1, a
        ST x, R1

    3.  LD R1, a
        ADD R1, R1, #1
        ST x, R1

    4.  LD R1, a
        LD R2, b
        ADD R1, R1, R2
        ST x, R1

    5.  LD R1, b
        LD R2, c
        MUL R1, R1, R2
        LD R3, a
        ADD R3, R3, R1
        ST y, R3

Note：5 small problem that can be inserted in the third row of the assembler code generation ST x, R1and LD R1, xtwo, which belong to two redundant code (redundant store-load). It is easy to generate such redundant code using a simple code generation strategy. Slower is slower but correct. There is a redundant store-load elimination, so the students don’t feel the answer in this question. All right.

### 8.2.2

Generate code for the following three-address statements assuming a and b are arrays whose elements are 4-byte values.

1. The four-statement sequence

        x = a[i]
        y = b[j]
        a[i] = y
        b[j] = x

2. The three-statement sequence

        x = a[i]
        y = b[i]
        z = x * y

3. The three-statement sequence

        x = a[i]
        y = b[x]
        a[i] = y

#### answer

    1.  LD R1, i
        MUL R1, R1, #4
        LD R2, a(R1)
        LD R3, j
        MUL R3, R3, #4
        LD R4, b(R3)
        ST a(R1), R4
        ST b(R3), R2

    2.  LD R1, i
        MUL R1, R1, #4
        LD R2, a(R1)
        LD R1, b(R1)
        MUL R1, R2, R1
        ST z, R1

    3.  LD R1, i
        MUL R1, R1, #4
        LD R2, a(R1)
        MUL R2, R2, #4
        LD R2, b(R2)
        ST a(R1), R2

### 8.2.3

Generate code for the following three-address sequence assuming that p and q are in memory locations:

    y = *q
    q = q + 4
    *p = y
    p = p + 4

#### answer

    LD R1, q
    LD R2, 0(R1)
    ADD R1, R1, #4
    ST q, R1
    LD R1, p
    ST 0(R1), R2
    ADD R1, R1, #4
    ST p, R1

### 8.2.4

Generate code for the following sequence assuming that x, y, and z are in memory locations:

        if x < y goto L1
        z = 0
        goto L2
    L1: z = 1

#### answer

        LD R1, x
        LD R2, y
        SUB R1, R1, R2
        BLTZ R1, L1
        LD R1, #0
        ST z, R1
        BR L2
    L1: LD R1, #1
        ST z, R1

Note：When the code is actually generated, the label will be assigned to a specific numeric address, but this section has not yet reached that point. It is good to just write the label name in the original title.

### 8.2.5

Generate code for the following sequence assuming that n is in a memory location:

        s = 0
        i = 0
    L1: if i > n goto L2
        s = s + i
        i = i + 1
        goto L1
    L2:

#### answer

    Long version:

        LD R1, #0
        ST s, R1
        ST i, R1
    L1: LD R1, i
        LD R2, n
        SUB R2, R1, R2
        BGTZ R2, L2
        LD R2, s
        ADD R2, R2, R1
        ST s, R2
        ADD R1, R1, #1
        ST i, R1
        BR L1
    L2:

    Short version:

        LD R2, #0
        LD R1, R2
        LD R3, n
    L1: SUB R4, R1, R3
        BGTZ R4, L2
        ADD R2, R2, R1
        ADD R1, R1, #1
        BR L1
    L2:

Note：Short version of the optimization 1) eliminate redundant memory - read 2) loop invariant code outside 3) then add register allocation
### 8.2.6

Determine the costs of the following instruction sequences:

    1.  LD R0, y
        LD R1, z
        ADD R0, R0, R1
        ST x, R0

    2.  LD R0, i
        MUL R0, R0, 8
        LD R1, a(R0)
        ST b, R1

    3.  LD R0, c
        LD R1, i
        MUL R1, R1, 8
        ST a(R1),R0

    4.  LD R0, p
        LD R1, 0(R0)
        ST x, R1

    5.  LD R0, p
        LD R1, x
        ST 0(R0), R1

    6.  LD R0, x
        LD R1, y
        SUB R0, R0, R1
        BLTZ *R3, R0

#### answer

1. 2 + 2 + 1 + 2 = 7
2. 2 + 2 + 2 + 2 = 8
3. 2 + 2 + 2 + 2 = 8
4. 2 + 2 + 2 = 6
5. 2 + 2 + 2 = 6
6. 2 + 2 + 1 + 1 = 6

Note： The instruction set used in this book does not explicitly define the details of all instructions, but it seems that the use of variable names to specify memory addresses actually implies the assumption that these variables are statically allocated, that is, in the actual generated instructions. These variable names are replaced with their corresponding numeric address constants, and the address exists in an extra word after the instruction, which is even more than one unit of overhead.


---

### Note

1. Obviously, this section is written very casually. The recommended numeric constants should be prefixed with #, except in the address. For example, LD R1, #1and ADD R1, R1, #1.

2. In this book, Ri stands for the ith register.

In the process of translating into assembly code, is it possible to arbitrarily specify the value of i (such as R3, R4, R1000) or is there a certain limit?

Answer: It is now free. When there are restrictions on the number of registers, consider the case of restrictions.

3. Also, if the R1 shown in the code is not used in the code that follows, can the new value be loaded into R1? If you can, how do you know that the previous R1 is not needed?

Answer: Can be overwritten. As for how to know that the previous value is dead, you need to look at the def-use chain. This is an important issue for optimization. For example, the 9.2.5 section says live variable is related to this.

b = a[i] corresponding sink code:

    ```
    LD R1, i
    MUL R1, R1, 8
    LD R2, a(R1)
    ...
    ```
Where a does it need to be loaded into the register first?

Answer: There is a hypothesis here: variables are stored statically. The situation will change when it comes to non-static variables.
